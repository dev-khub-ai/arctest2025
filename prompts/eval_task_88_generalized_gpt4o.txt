
# ✅ Generalized Rule for Grid Transformation Tasks (Multi–Program, Degenerate Support)

You are solving grid transformation tasks where you must transform an input grid into an output grid by **extracting templates from detected objects** and **stamping them at target positions** determined by adjacent program–bar cells.

This rule handles:
- ✅ Any number of programs in the input grid.
- ✅ Multiple objects and multiple program–bars.
- ✅ Degenerate programs (objects with only a single program–bar candidate).
- ✅ Overlapping stamps with deterministic resolution.

Follow these steps carefully and systematically:

---

## Step 1: Object Detection (Find All Objects)

- Scan the input grid for **connected components** of the designated object pixel (e.g., value "8").
- Use **8–way connectivity**.
- Collect all distinct objects.

---

## Step 2: Program–Bar Detection (Per Object)

- For each object, inspect the cells **immediately adjacent** to its bounding box (shared edge).
- Find **all pairs** of adjacent, nonzero, non–object cells:
  - These are your **candidate program–bars**.
- If an object has no adjacent pair, but **at least one candidate cell**, treat it as a **degenerate program** (see Step 2b).

### Step 2b: Degenerate Programs (Optional, Powerful)

- If an object has a single adjacent non–object, nonzero candidate, treat it as a degenerate program:
  - Assign this cell as **c₁** (template value).
  - Assign **c₂** to **default target pixels**, typically background zeros or another heuristic.
- Degenerate programs are crucial for tasks where you need to fill large background layers.

---

## Step 3: Program Assignment (Per Program)

- For each program–bar:
  - Assign **c₁**: the cell of the program–bar closer to the object (Euclidean or Manhattan distance).
  - Assign **c₂**: the farther cell.

- For degenerate programs:
  - **c₁**: the candidate cell’s value.
  - **c₂**: chosen by heuristic (usually background zeros).

---

## Step 4: Anchor Selection (Per Program)

- For each program:
  - Find an object pixel that is **edge–adjacent** to **c₁**.
  - If none, select the object pixel **nearest to c₁** (Euclidean distance, deterministic tie-breaker: top–left).

- Compute the **Anchor–Relative Offset**:
  ```
  Offset = (Anchor Coordinate) − (Bounding Box Top–Left)
  ```

---

## Step 5: Template Extraction (Per Program)

- Extract the bounding box of the object.
- Replace object pixels with **c₁**.
- Leave background pixels unchanged.
- This yields your **template (T)** for this program.

---

## Step 6: Target Selection (Per Program)

- Find **all input grid pixels** whose value equals **c₂**.
- Exclude:
  - Any cell inside any object’s bounding box.
  - Any program–bar cells.
- For degenerate programs:
  - Select **background target cells** (e.g., input value = 0), excluding global exclusions.

---

## Step 7: Stamping (Per Program)

- For each target cell **T**, compute stamp position:
  ```
  Stamp Top–Left = T − Offset
  ```

- Overlay the template **T** at this position:
  - Template nonzero values overwrite output grid.
  - Apply clipping if stamp extends beyond grid edges.

- **Deterministic stamping order:**
  - Process targets in row–major order (sort by row, then column).
  - This ensures consistency between isolated stamps and full output.

---

## Step 8: Merge Programs

- After stamping all programs:
  - Merge all intermediate grids into a final output grid.
  - For overlapping stamps:
    - Later programs (determined by deterministic order of objects and program–bars) overwrite earlier ones.

- If needed, **post–process**:
  - Map template values to desired output palette (e.g., c₁ = 4 remapped to final output value "2").

---

## ✅ Applicability

This rule applies to any task where:
- Input grid contains connected objects with adjacent program–bars.
- Templates are extracted from objects and stamped onto the grid at target positions.
- Multiple programs may coexist in the input.
- Stamps may overlap.
- Background filling or layered structures are present.

---

## ✅ Notes for Robustness

- ⚙️ **Multiple Programs:**  
  Process each object and its program(s) independently.

- ⚙️ **Degenerate Programs:**  
  Use cautiously but consistently — powerful for background layers.

- ⚙️ **Overlap Resolution:**  
  Always apply stamps in deterministic order to ensure reproducibility.

- ⚙️ **Target Selection:**  
  Always exclude global exclusion zone (all objects + program–bars).

- ⚙️ **Debugging:**  
  Test isolated stamps and full union — they should produce consistent results.

---

## ✅ Final Result

Using this rule:
- Tasks with **1 program** (like Train Input 3) ✅ success.
- Tasks with **multiple programs** (like Test Input 88.2/2) ✅ success.
- Any number of programs in input grid ✅ success.

---

### This is your complete rulebook. ✅  
Production–ready, general, reliable.

---

